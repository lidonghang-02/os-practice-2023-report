# 并发和同步
1. 并发：指多个控制流同时执行
	- 多处理器多任务：内存共享，每个处理器执行一个任务流，相互之间完全独立
	- 单处理器多任务：一个处理器通过调度执行多个任务流，多个控制流共享一个处理器和内存
	- 单处理器任务+中断：一个处理器执行任务，配合中断实现多个任务的处理
2. 同步：为了保证在并发执行的环境中各个控制流可以有效执行而采用的一种编程技术。
# 临界区、锁、死锁
### 临界区：
- 在并发的程序执行环境中，所谓临界区(Critical Section)指得是一个会访问共享资源（例如：一个共享设备或者一块共享内存）的指令片段，而且当这样的多个指令片段同时访问某个共享资源时可能会引发问题。
### 锁
- 在并发环境下为了有效控制临界区的执行（同步），我们要做的是当有一个控制流进入临界区时，其他相关控制流必须**等待**。 锁是一种最常见的用来实现同步的技术。
	- 不可睡眠的锁
	- 可睡眠的锁

![](pic/pic2/Pasted%20image%2020230806131940.png)
- `aquire(lock)`加锁
- `release(unlock)`释放锁
### 死锁问题
- 当控制流执行路径中会涉及多个锁，并且这些控制流执行路径获取(aquire)锁的顺序不同时就可能会发生死锁问题。
- 例如：任务1锁住A，任务2锁住B，然后任务1需要锁住B，但是任务2已经锁住了B，于是等待解锁，此时任务2又想锁住任务A，但是任务1已经锁住了A，此时等待卡死。
![](pic/pic2/Pasted%20image%2020230806132543.png)
### 如何解决死锁
- 调整获取(aquire)锁的顺序，譬如保持一致。
- 尽可能防止任务在持有一把锁的同时申请其他的锁。
- 尽可能少用锁，尽可能少并发
# 自旋锁的实现
> 自旋锁（Spin Lock）属于不可睡眠的锁
- 代码实现逻辑
![](pic/pic2/Pasted%20image%2020230806140804.png)
上面代码只是简单的展示代码的实现逻辑，没有保证读取锁状态和上锁的操作的原子性。
### 自旋锁的使用
- 自旋锁可以防止多个任务同时进入临界区
- 在自旋锁保护的临界区中不能执行长时间操作
- 在自旋锁保护的临界区中不能主动放弃CPU
# 其他同步技术
![](pic/pic2/Pasted%20image%2020230806142503.png)
